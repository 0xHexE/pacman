#! /usr/bin/python
#
#   rankmirrors : read a list of mirrors from a file and rank them by speed
#
#   Original Idea copyright (c) 2006 R.G. <chesercat>
#   Modified 2006 by Dan McGee <dpmcgee@gmail.com>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
#   USA.
#
import sys, datetime, time, socket, urllib2
from optparse import OptionParser

def createOptParser():
    usage = "usage: %prog [options] MIRRORFILE"
    description = "Ranks pacman mirrors by their connection and opening speed. Pacman mirror files are located in /etc/pacman.d/."
    parser = OptionParser(usage=usage,description=description)
    parser.add_option("-f", "--formatted", action="store_true",
            dest = "formatted", default=False, help="output in mirror file format")
    parser.add_option("-n", dest="num", default=0,
            help="number of servers to output, 0 for all")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
            default=False, help="be verbose in output")
    return parser

def timeCmd(cmd):
    before = time.time();
    try:
        cmd();
    except KeyboardInterrupt, ki:
        raise ki
    except socket.timeout, ioe:
        return 'timeout'
    except Exception, e:
        return 'unreachable'
    return time.time() - before;

def talkToServer(serverUrl):
    opener = urllib2.build_opener()
    tmp = opener.open(serverUrl).read()

def getFuncToTime(serverUrl):
    return lambda : talkToServer(serverUrl)

def cmpPairBySecond(p1, p2):
    if p1[1] == p2[1]: return 0
    if p1[1] < p2[1]: return -1
    return 1

if __name__ == "__main__":
    parser = createOptParser()
    (options, args) = parser.parse_args()

    if len(args) != 1:
        parser.print_help(sys.stderr)
        sys.exit(0)

    # allows connections to time out if they take too long
    socket.setdefaulttimeout(10)

    fl = open(args[0], 'r')
    serverToTime = {}
    if options.formatted:
        print "# Server list generated by rankmirrors on", datetime.date.today()
    else:
        print 'Querying servers, this may take some time...'
    for ln in fl.readlines():
        splitted = ln.split('=')
        if splitted[0].strip() != 'Server':
            if options.formatted:
                print ln,
            continue

        serverUrl = splitted[1].strip()
        if serverUrl[-1] == '\n': serverUrl = serverUrl[0:-1]
        if options.verbose and options.formatted:
            print '#',serverUrl,'...',
        elif options.verbose:
            print serverUrl,'...',
        elif not options.formatted:
            print ' * ',
        sys.stdout.flush()
        serverToTime[serverUrl] = timeCmd(getFuncToTime(serverUrl))
        if options.verbose:
            print serverToTime[serverUrl]

    items = serverToTime.items()
    items.sort(cmpPairBySecond)
    numToShow = int(options.num)
    if numToShow == 0: numToShow = len(items)
    if len(items) > 0:
        if options.formatted:
            for i in items[0:numToShow]:
                print 'Server =', i[0]
        else:
            print
            print ' Servers sorted by time:'
            for i in items[0:numToShow]:
                print i[1], ':', i[0]

# vim: set ts=4 sw=4 et:
