#!/bin/bash
#
#   repo-add - add a package to a given repo database file
#   @configure_input@
#
#   Copyright (c) 2006 Aaron Griffin <aaron@archlinux.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.

# gettext initialization
export TEXTDOMAIN='pacman'
export TEXTDOMAINDIR='@localedir@'

myver='@PACKAGE_VERSION@'
confdir='@sysconfdir@'

FORCE=0
REPO_DB_FILE=""

# ensure we have a sane umask set
umask 0022

msg() {
	local mesg=$1; shift
	printf "==> ${mesg}\n" "$@" >&1
}

msg2() {
	local mesg=$1; shift
	printf "  -> ${mesg}\n" "$@" >&1
}

warning() {
	local mesg=$1; shift
	printf "==> $(gettext "WARNING:") ${mesg}\n" "$@" >&2
}

error() {
	local mesg=$1; shift
	printf "==> $(gettext "ERROR:") ${mesg}\n" "$@" >&2
}

# print usage instructions
usage() {
	printf "repo-add (pacman) %s\n\n" "$myver"
	printf "$(gettext "Usage: %s <path-to-db> [--force] <package> ...\n\n")" "$0"
	printf "$(gettext "\
repo-add will update a package database by reading a package file.\n\
Multiple packages to add can be specified on the command line.\n\n")"
	printf "$(gettext "\
The --force flag will add a 'force' entry to the sync database, which\n\
tells pacman to skip its internal version number checking and update\n\
the package regardless.\n\n")"
	echo "$(gettext "Example:  repo-add /path/to/repo.db.tar.gz pacman-3.0.0.pkg.tar.gz")"
}

version() {
	printf "repo-add (pacman) %s\n" "$myver"
	printf "$(gettext "\
Copyright (C) 2006 Aaron Griffin <aaron@archlinux.org>.\n\n\
This is free software; see the source for copying conditions.\n\
There is NO WARRANTY, to the extent permitted by law.\n")"
}

# test if a file is a repository DB
test_repo_db_file () {
	if [ -f "$REPO_DB_FILE" ]; then
		if bsdtar -tf "$REPO_DB_FILE" | grep -q "/desc"; then
			return 0 # YES
		fi
	else
		return 0 # YES - No database file is also allowed
	fi

	return 1 # NO
}

# write a list entry
#		arg1 - Entry name
#		arg2 - List
#		arg3 - File to write to
write_list_entry() {
	if [ -n "$2" ]; then
		echo "%$1%" >>$3
		echo $2 | tr -s ' ' '\n' >>$3
		echo "" >>$3
	fi
}

# write a delta entry to the pacman database
#   arg1 - path to delta
db_write_delta()
{
	# blank out all variables and set deltafile
	local deltafile=$(readlink -f "$1")
	local filename=$(basename "$deltafile")
	local deltavars pkgname fromver tover arch csize md5sum

	# format of the delta filename:
	# (package)-(fromver)_to_(tover)-(arch).delta
	deltavars=( $(echo "$filename" | sed -e 's/\(.*\)-\(.*-.*\)_to_\(.*-.*\)-\(.*\).delta/\1 \2 \3 \4/') )
	pkgname=${deltavars[0]}
	fromver=${deltavars[1]}
	tover=${deltavars[2]}
	arch=${deltavars[3]}

	# get md5sum and size of delta
	md5sum="$(md5sum "$deltafile" | cut -d ' ' -f 1)"
	csize=$(du -b -L "$deltafile" | cut -f 1)

	# ensure variables were found
	if [ -z "$pkgname" -o -z "$fromver" -o -z "$tover" -o -z "$arch" ]; then
		return 1
	fi

	# add the entry for this delta file
	echo -e "$fromver $tover $csize $filename $md5sum" >>deltas
} # end db_write_delta


# write an entry to the pacman database
#   arg1 - path to package
db_write_entry()
{
	# blank out all variables and set pkgfile
	local pkgfile=$(readlink -f "$1")
	local pkgname pkgver pkgdesc url builddate packager csize size \
		group depend backup license replaces provides conflict \
		_groups _depends _backups _licenses _replaces _provides _conflicts \
		startdir

	local OLDIFS="$IFS"
	# IFS (field separator) is only the newline character
	IFS="
"

	# read info from the zipped package
	local line
	for line in $(bsdtar -xOf "$pkgfile" .PKGINFO | \
		grep -v "^#" | sed 's|\(\w*\)\s*=\s*\(.*\)|\1="\2"|'); do
		eval "$line"
		case "$line" in
			group=*)    _groups="$_groups $group" ;;
			depend=*)   _depends="$_depends $depend" ;;
			backup=*)   _backups="$_backups $backup" ;;
			license=*)  _licenses="$_licenses $license" ;;
			replaces=*) _replaces="$_replaces $replaces" ;;
			provides=*) _provides="$_provides $provides" ;;
			conflict=*) _conflicts="$_conflicts $conflict" ;;
		esac
	done

	IFS=$OLDIFS

	# get compressed size of package
	csize=$(du -b -L "$pkgfile" | cut -f 1)

	startdir=$(pwd)
	pushd "$gstmpdir" 2>&1 >/dev/null

	# ensure $pkgname and $pkgver variables were found
	if [ -z "$pkgname" -o -z "$pkgver" ]; then
		error "$(gettext "Invalid package file '%s'.")" "$pkgfile"
		popd 2>&1 >/dev/null
		return 1
	fi

	# remove any other package in the DB with same name
	local existing
	for existing in *; do
		if [ "${existing%-*-*}" = "$pkgname" ]; then
			msg2 "$(gettext "Removing existing package '%s'...")" "$existing"
			rm -rf "$existing"
		fi
	done

	# create package directory
	mkdir "$pkgname-$pkgver"
	cd "$pkgname-$pkgver"

	# create desc entry
	msg2 "$(gettext "Creating 'desc' db entry...")"
	echo -e "%FILENAME%\n$(basename "$1")\n" >>desc
	echo -e "%NAME%\n$pkgname\n" >>desc
	echo -e "%VERSION%\n$pkgver\n" >>desc
	[ -n "$pkgdesc" ] && echo -e "%DESC%\n$pkgdesc\n" >>desc
	write_list_entry "GROUPS" "$_groups" "desc"
	[ -n $csize ] && echo -e "%CSIZE%\n$csize\n" >>desc
	[ -n $size ] && echo -e "%ISIZE%\n$size\n" >>desc

	# compute checksums
	msg2 "$(gettext "Computing md5 checksums...")"
	echo -e "%MD5SUM%\n$(md5sum "$pkgfile" | cut -d ' ' -f 1)\n" >>desc

	[ -n "$url" ] && echo -e "%URL%\n$url\n" >>desc
	write_list_entry "LICENSE" "$_licenses" "desc"
	[ -n "$arch" ] && echo -e "%ARCH%\n$arch\n" >>desc
	[ -n "$builddate" ] && echo -e "%BUILDDATE%\n$builddate\n" >>desc
	[ -n "$packager" ] && echo -e "%PACKAGER%\n$packager\n" >>desc
	write_list_entry "REPLACES" "$_replaces" "desc"
	[ $FORCE -eq 1 ] && echo -e "%FORCE%\n" >>desc

	# create depends entry
	msg2 "$(gettext "Creating 'depends' db entry...")"
	write_list_entry "DEPENDS" "$_depends" "depends"
	write_list_entry "CONFLICTS" "$_conflicts" "depends"
	write_list_entry "PROVIDES" "$_provides" "depends"

	# create deltas entry if there are delta files
	for delta in $startdir/$pkgname-*-*_to_*-*-$arch.delta; do
		# This for loop also pulls in all files that start with the current package
		# name and are followed by a -whatever. For instance, running this loop for
		# gcc would also grab gcc-libs. To guard against this, compare the package
		# name of the delta to the current package name.
		local filename=$(basename "$delta")
		local dpkgname="$(echo "$filename" | sed -e 's/\(.*\)-.*-.*_to_.*-.*-.*.delta/\1/')"
		if [ "$pkgname" = "$dpkgname" -a -f "$delta" ]; then
			# create deltas file if it does not already exist
			if [ ! -f "deltas" ]; then
				msg2 "$(gettext "Creating 'deltas' db entry...")"
				echo -e "%DELTAS%" >>deltas
			fi

			# write this delta entry
			if db_write_delta "$delta"; then
				msg2 "$(gettext "Added delta '%s'")" "$(basename "$delta")"
			else
				msg2 "$(gettext "Could not add delta '%s'")" "$(basename "$delta")"
			fi
		fi
	done
	# add the final newline
	[ -f "deltas" ] && echo -e "" >>deltas

	# preserve the modification time
	touch -r "$pkgfile" desc depends
	[ -f "deltas" ] && touch -r "$pkgfile" deltas

	popd 2>&1 >/dev/null
} # end db_write_entry

# PROGRAM START

# check for help flags
if [ "$1" = "-h" -o "$1" = "--help" ]; then
	usage
	exit 0
fi

# check for version flags
if [ "$1" = "-V" -o "$1" = "--version" ]; then
	version
	exit 0
fi

# check for correct number of args
if [ $# -lt 2 ]; then
	usage
	exit 1
fi

# source system and user makepkg.conf
if [ -r "$confdir/makepkg.conf" ]; then
	source "$confdir/makepkg.conf"
else
	error "$(gettext "%s not found. Cannot continue.")" "$confdir/makepkg.conf"
	exit 1 # $E_CONFIG_ERROR
fi

if [ -r ~/.makepkg.conf ]; then
	source ~/.makepkg.conf
fi

# main routine
gstmpdir=$(mktemp -d /tmp/repo-add.XXXXXXXXXX) || (\
	error "$(gettext "Cannot create temp directory for database building.")"; \
	exit 1)

success=0
# parse arguments
for arg in "$@"; do
	if [ "$arg" == "--force" -o "$arg" == "-f" ]; then
		FORCE=1
	elif [ -z "$REPO_DB_FILE" ]; then
		REPO_DB_FILE=$(readlink -f "$arg")
		if ! test_repo_db_file; then
			error "$(gettext "Repository file '%s' is not a proper pacman database.")" "$REPO_DB_FILE"
			exit 1
		elif [ -f "$REPO_DB_FILE" ]; then
			msg "$(gettext "Extracting database to a temporary location...")"
			bsdtar -xf "$REPO_DB_FILE" -C "$gstmpdir"
		fi
	else
		if [ -f "$arg" ]; then
			if ! bsdtar -tf "$arg" .PKGINFO 2>&1 >/dev/null; then
				error "$(gettext "'%s' is not a package file, skipping")" "$arg"
			else
				msg "$(gettext "Adding package '%s'")" "$arg"

				if db_write_entry "$arg"; then
					success=1
				fi
			fi
		else
			error "$(gettext "Package '%s' not found.")" "$arg"
		fi
	fi
done

# if all operations were a success, re-zip database
if [ $success -eq 1 ]; then
	msg "$(gettext "Creating updated database file %s")" "$REPO_DB_FILE"
	pushd "$gstmpdir" 2>&1 >/dev/null

	if [ -n "$(ls)" ]; then
		[ -f "${REPO_DB_FILE}.old" ] && rm "${REPO_DB_FILE}.old"
		[ -f "$REPO_DB_FILE" ] && mv "$REPO_DB_FILE" "${REPO_DB_FILE}.old"

		case "$DB_COMPRESSION" in
			gz)  TAR_OPT="z" ;;
			bz2) TAR_OPT="j" ;;
			*)   warning "$(gettext "No compression set.")" ;;
		esac

		bsdtar -c${TAR_OPT}f "$REPO_DB_FILE" *
	fi

	popd 2>&1 >/dev/null
else
	msg "$(gettext "No packages modified, nothing to do.")"
fi

# remove the temp directory used to unzip
[ -d "$gstmpdir" ] && rm -rf "$gstmpdir"

# vim: set ts=2 sw=2 noet:
