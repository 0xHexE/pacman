#!/bin/bash
#
#   bacman: recreate a package from a running system
#   This script rebuilds an already installed package using metadata
#   stored into the pacman database and system files
#
#   Copyright (c) 2008 locci <carlocci_at_gmail_dot_com>
#   Copyright (c) 2008-2016 Pacman Development Team <pacman-dev@archlinux.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

shopt -s extglob
shopt -s nullglob

declare -r myname='bacman'
declare -r myver='@PACKAGE_VERSION@'
USE_COLOR='y'
INCLUDE_PACNEW='n'
# Required for fakeroot because options are shifted off the array.
ARGS=("$@")

m4_include(../scripts/library/output_format.sh)
m4_include(../scripts/library/parseopts.sh)

# Lazy recursive clean up of temporary dirs
work_dir_root="${TMPDIR:-/tmp}/bacman"
clean_up() {
	rm -rf "$work_dir_root".*
	echo
	exit
}
# Trap termination signals
trap clean_up SIGHUP SIGINT SIGTERM

# Print usage information
usage() {
	printf "%s (pacman) %s\n" "$myname" "$myver"
	echo
	printf -- "$(gettext "Recreate packages using pacman's database and system files")\n"
	echo
	printf -- "$(gettext "Usage: %s [options] <package(s)>")\n" "$0"
	echo
	printf -- "$(gettext "Options:")\n"
	printf -- "$(gettext "  -h, --help       Show this help message and exit")\n"
	printf -- "$(gettext "  -m, --nocolor    Disable colorized output messages")\n"
	printf -- "$(gettext "  --pacnew         Package .pacnew files")\n"
	echo
	printf -- "$(gettext "Examples:")" 
	printf -- "    %s linux-headers\n" "$myname"
	printf -- "    %s --nocolor --pacnew gzip make binutils\n" "$myname"
	printf -- "    %s \$(pacman -Qq)\n" "$myname"
	echo
}

# Print version information
version() {
	printf "%s %s\n" "$myname" "$myver"
	echo 'Copyright (C) 2008 locci <carlocci_at_gmail_dot_com>'
	echo 'Copyright (C) 2008-2016 Pacman Development Team <pacman-dev@archlinux.org>'
}


# Printing the usage information takes precedence over every other parameter
for option in "$@"; do
	[[ $option == "-h" || $option == "--help" ]] && usage && exit 0
done

# Parse arguments
OPT_SHORT='mv'
OPT_LONG=('nocolor' 'pacnew' 'version')
if ! parseopts "$OPT_SHORT" "${OPT_LONG[@]}" -- "$@"; then
	usage
	exit 1
fi
set -- "${OPTRET[@]}"
unset OPT_SHORT OPT_LONG OPTRET

while :; do
	case "$1" in
		-m|--nocolor)
			USE_COLOR='n' ;;
		--pacnew)
			INCLUDE_PACNEW='y' ;;
		-v|--version)
			version
			exit 0 ;;
		--)
			shift
			break 2 ;;
	esac
	shift
done

# Configure colored output
m4_include(../scripts/library/term_colors.sh)

# Retrieve the list of packages to be assembled and break if none was specified
pkg_list=($*)
if [[ ${#pkg_list[@]} == 0 ]]; then
	usage
	exit 1
fi

# Run with fake root privileges if EUID is not root
if (( EUID )); then
	if [[ -f /usr/bin/fakeroot ]]; then
		msg "Entering fakeroot environment"
		export INFAKEROOT="1"
		/usr/bin/fakeroot -u -- "$0" "${ARGS[@]}"
		exit $?
	else
		warning "installing fakeroot or running $myname as root is required to"
		plain   "         preserve the ownership permissions of files in some packages\n"
	fi
fi

# Source environmental variables and specify fallbacks
if [[ ! -r @sysconfdir@/pacman.conf ]]; then
	error "unable to read @sysconfdir@/pacman.conf"
	exit 1
fi
eval $(awk '/DBPath/ {print $1$2$3}' @sysconfdir@/pacman.conf)
pac_db="${DBPath:-@localstatedir@/lib/pacman/}/local"
if [[ ! -r @sysconfdir@/makepkg.conf ]]; then
	error "unable to read @sysconfdir@/makepkg.conf"
	exit 1
fi
source "@sysconfdir@/makepkg.conf"
if [[ -r ~/.makepkg.conf ]]; then
	source ~/.makepkg.conf
fi
pkg_dest="${PKGDEST:-$PWD}"
pkg_pkger="${PACKAGER:-'Unknown Packager'}"

# Check for an existing database
if [[ ! -d $pac_db ]]; then
	error "pacman database directory ${pac_db} not found"
	exit 1
fi

# Assemble a single package: $1 = pkgname
fakebuild() {
	pkg_name="$1"
	pkg_dir=("$pac_db/$pkg_name"-+([^-])-+([^-]))
	pkg_namver=("${pkg_dir[@]##*/}")

	# Checks database for specified package
	if (( ${#pkg_dir[@]} != 1 )); then
		error "%d entries for package %s found in pacman database" \
			${#pkg_dir[@]} "${pkg_name}"
		msg2 "%s" "${pkg_dir[@]}"
		exit 1
	fi
	if [[ ! -d $pkg_dir ]]; then
		error "package %s is found in pacman database," "${pkg_name}"
		plain "       but '%s' is not a directory" "${pkg_dir}"
		exit 1
	fi

	# Create working directory
	msg "Package: ${pkg_namver}"
	work_dir=$(mktemp -d "${work_dir_root}.XXXXXXXXXX")
	cd "$work_dir" || exit 1

	# Assemble list of files which belong to the package and tar them
	msg2 "Copying package files..."

	while read i; do
		if [[ -z $i ]]; then
			continue
		fi

		if [[ $i == %+([A-Z])% ]]; then
			current=$i
			continue
		fi

		case "$current" in
			%FILES%)
				local_file="/$i"
				package_file="$work_dir/$i"

				if [[ ! -e $local_file ]]; then
					warning "package file $local_file is missing"
					continue
				fi
				;;

			%BACKUP%)
				# Get the MD5 checksum.
				original_md5="${i##*$'\t'}"
				# Strip the md5sum after the tab.
				i="${i%$'\t'*}"
				local_file="/$i.pacnew"
				package_file="$work_dir/$i"

				# Include unmodified .pacnew files.
				local_md5="$(md5sum "$local_file" | cut -d' ' -f1)"
				if [[ $INCLUDE_PACNEW == 'n' ]] \
				|| [[ ! -e $local_file ]] \
				|| [[ $local_md5 != $original_md5 ]]; then
					# Warn about modified files.
					local_md5="$(md5sum "/$i" | cut -d' ' -f1)"
					if [[ $local_md5 != $original_md5 ]]; then
						warning "package file /$i has been modified"
					fi
					# Let the normal file be included in the %FILES% list.
					continue
				fi
				;;

			*)
				continue
				;;
		esac

		# Tar files
		ret=0
		bsdtar -cnf - -s'/.pacnew$//' "$local_file" 2> /dev/null | bsdtar -xpf - 2> /dev/null
		# Workaround to bsdtar not reporting a missing file as an error
		if ! [[ -e $package_file || -L $package_file ]]; then
			error "unable to add $local_file to the package"
			plain "       If your user does not have permission to read this file, then"
			plain "       you will need to run $myname as root."
			rm -rf "$work_dir"
			exit 1
		fi
	done < "$pkg_dir"/files

	ret=$?
	if (( ret )); then
		rm -rf "$work_dir"
		exit 1
	fi

	# Calculate package size
	pkg_size=$(du -sk | awk '{print $1 * 1024}')

	# Reconstruct .PKGINFO from database
	# TODO adopt makepkg's write_pkginfo() into this or scripts/library
	msg2 "Generating .PKGINFO metadata..."
	echo "# Generated by $myname $myver"    > .PKGINFO
	if [[ $INFAKEROOT == "1" ]]; then
		echo "# Using $(fakeroot -v)"    >> .PKGINFO
	fi
	echo "# $(LC_ALL=C date)"    >> .PKGINFO
	echo "#"    >> .PKGINFO
	while read i; do
		if [[ -z $i ]]; then
			continue;
		fi
		if [[ $i == %+([A-Z])% ]]; then
			current=$i
			continue
		fi

		case "$current" in
			# desc
			%NAME%)
				echo "pkgname = $i"    >> .PKGINFO
				;;
			%VERSION%)
				echo "pkgver = $i"    >> .PKGINFO
				;;
			%DESC%)
				echo "pkgdesc = $i"    >> .PKGINFO
				;;
			%URL%)
				echo "url = $i"    >> .PKGINFO
				;;
			%LICENSE%)
				echo "license = $i"    >> .PKGINFO
				;;
			%ARCH%)
				echo "arch = $i"    >> .PKGINFO
				pkg_arch="$i"
				;;
			%BUILDDATE%)
				echo "builddate = $(date -u "+%s")"    >> .PKGINFO
				;;
			%PACKAGER%)
				echo "packager = $pkg_pkger"        >> .PKGINFO
				;;
			%SIZE%)
				echo "size = $pkg_size"        >> .PKGINFO
				;;
			%GROUPS%)
				echo "group = $i"    >> .PKGINFO
				;;
			%REPLACES%)
				echo "replaces = $i"    >> .PKGINFO
				;;
			%DEPENDS%)
				echo "depend = $i"   >> .PKGINFO
				;;
			%OPTDEPENDS%)
				echo "optdepend = $i" >> .PKGINFO
				;;
			%CONFLICTS%)
				echo "conflict = $i" >> .PKGINFO
				;;
			%PROVIDES%)
				echo "provides = $i"  >> .PKGINFO
				;;
			%BACKUP%)
				# Strip the md5sum after the tab
				echo "backup = ${i%%$'\t'*}"   >> .PKGINFO
				;;
		esac
	done < <(cat "$pkg_dir"/{desc,files})

	comp_files=".PKGINFO"

	# Add instal file if present
	if [[ -f $pkg_dir/install ]]; then
		cp "$pkg_dir/install" "$work_dir/.INSTALL"
		comp_files+=" .INSTALL"
	fi
	if [[ -f $pkg_dir/changelog ]]; then
		cp "$pkg_dir/changelog" "$work_dir/.CHANGELOG"
		comp_files+=" .CHANGELOG"
	fi

	# Fixes owner:group and permissions for .PKGINFO, .CHANGELOG, .INSTALL
	chown root:root "$work_dir"/{.PKGINFO,.CHANGELOG,.INSTALL} 2> /dev/null
	chmod 644 "$work_dir"/{.PKGINFO,.CHANGELOG,.INSTALL} 2> /dev/null

	# Generate the package
	msg2 "Generating the package..."

	pkg_file="$pkg_dest/$pkg_namver-$pkg_arch${PKGEXT}"
	ret=0

	# Move compressed package to destination
	# TODO: Maybe this can be set globally for robustness
	shopt -s -o pipefail
	bsdtar -cf - $comp_files * |
	case "$PKGEXT" in
		*tar.gz)  gzip -c -f -n ;;
		*tar.bz2) bzip2 -c -f ;;
		*tar.xz)  xz -c -z - ;;
		*tar.Z)   compress -c -f ;;
		*tar)     cat ;;
		*) warning "'%s' is not a valid archive extension." \
		"$PKGEXT"; cat ;;
	esac > "${pkg_file}"; ret=$?

	# Evaluate return code
	if (( ret )); then
		error "Unable to write package to $pkg_dest"
		plain "       Maybe the disk is full or you do not have write access"
		rm -rf "$work_dir"
		exit 1
	fi

	# Clean up working directory
	rm -rf "$work_dir"
}


for PKG in ${pkg_list[@]}; do
	fakebuild $PKG
done
msg "Done."

exit 0

# vim: set noet:
